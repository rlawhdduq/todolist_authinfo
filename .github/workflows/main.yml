name: Build and Deploy Spring Boot Application via SSH

on:
  push:
    branches: 
      - kjy  # 타겟 브랜치
      
jobs:
  build:
    runs-on: ubuntu-latest # Ubunt로 실행

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          
      - name: Add Permissions for gralde wrapper
        run: chmod +x ./gradlew
        
      - name: Build with Gradle
        run: |
            ./gradlew clean build -x test # 빌드 과정에서 테스트 생략 -> 후일 테스트까지 하게 바꿔봐야겠다.
            
      - name: Deploy .jar File
        run: |
            pwd
            ls -al
            echo "${{ secrets.SSH_PRIVATE_KEY }}" | tr -d '\r' > private_key.pem
            chmod 600 private_key.pem
            # build/libs에서 실행 가능한 하나의 .jar 파일 이름만 찾기
            # (-plain.jar 같은 파일을 제외합니다)
            JAR_FILE=$(find $GITHUB_WORKSPACE/build/libs -name "*.jar" ! -name "*-plain.jar" | head -n 1)
            
            if [ -z "$JAR_FILE" ]; then
              echo "ERROR: No executable .jar file found."
              exit 1
            fi
            echo "Found .jar file: $JAR_FILE"
            # 이전 .jar 먼저 삭제
            ssh -o StrictHostKeyChecking=no -i private_key.pem -p 2222 ubuntukjy@${{ secrets.HOST_IP }} 'rm -f /spring/docker/compose/authinformation/jar/*.jar'
            # 새로운 .jar 복사
            scp -o StrictHostKeyChecking=no -i private_key.pem -P 2222 $JAR_FILE ubuntukjy@${{ secrets.HOST_IP }}:/spring/docker/compose/authinformation/jar
            
      - name: Set SSH ssh-action
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.HOST_IP }}
          username: ubuntukjy
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 2222
          script: |
                  # 이건 ssh연결 된 상태에서 실행되는거라 추후에 dockerfile build나 이런거 할 때 여기에 명령어 작성하면 될듯 아래 명령어들은 다 쓰레기임
                  echo "CD start"
                  cd /spring/docker/compose
                  # 빌드캐시, 이미지, 이전 컨테이너 완전 정리
                  docker builder prune -af || true
                  docker image prune -af || true
                  docker container prune -f || true

                  docker-compose -f docker-compose-authinformation.yaml down -v
                  # 이미지 강제로 전부 삭제, true는 이미지없어서 오류나도 계속 진행하라는 의미
                  docker rmi $(docker-compose -f docker-compose-authinformation.yaml images -q) || true
                  docker-compose -f docker-compose-authinformation.yaml up -d --build --force-recreate
                  echo "CD end"
